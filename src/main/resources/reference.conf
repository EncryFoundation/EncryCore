akka {
  log-dead-letters = 0
  log-dead-letters-during-shutdown = off
  persistence.journal.plugin = akka.persistence.journal.leveldb
  logger-startup-timeout = 60s
  loggers = ["akka.event.slf4j.Slf4jLogger"]
  loglevel = "WARNING"
  logging-filter = "akka.event.slf4j.Slf4jLoggingFilter"
  persistence {
    journal.leveldb {
      class = "akka.persistence.journal.leveldb.LeveldbJournal"
      plugin-dispatcher = "akka.persistence.dispatchers.default-plugin-dispatcher"
      replay-dispatcher = "akka.persistence.dispatchers.default-replay-dispatcher"
      dir = "leveldb/journal"
      fsync = on
      checksum = off
      native = on
      compaction-intervals {}
    }
    snapshot-store.local {
      class = "akka.persistence.snapshot.local.LocalSnapshotStore"
      plugin-dispatcher = "akka.persistence.dispatchers.default-plugin-dispatcher"
      stream-dispatcher = "akka.persistence.dispatchers.default-stream-dispatcher"
      dir = "leveldb/snapshots"
      max-load-attempts = 3
    }
  }
  actor {
    io {
      tcp {
        max-received-message-size = 400000
        # The number of bytes per direct buffer in the pool used to read or write
        # network data from the kernel.
        direct-buffer-size = 34096 KiB
        # The maximal number of direct buffers kept in the direct buffer pool for
        # reuse.
        direct-buffer-pool-limit = 800000
        trace-logging = on
      }
    }
    warn-about-java-serializer-usage = false
    debug {
      # enable function of LoggingReceive, which is to log any received message at
      # DEBUG level
      receive = on
      # enable DEBUG logging of all AutoReceiveMessages (Kill, PoisonPill etc.)
      autoreceive = on
      # enable DEBUG logging of actor lifecycle changes
      lifecycle = on
      # enable DEBUG logging of unhandled messages
      unhandled = on
      # enable DEBUG logging of all LoggingFSMs for events, transitions and timers
      fsm = on
      # enable DEBUG logging of subscription changes on the eventStream
      event-stream = on
      # If this is "on", Akka will log all outbound messages at DEBUG level,
      # if off then they are not logged
      log-sent-messages = on
      # If this is "on", Akka will log all inbound messages at DEBUG level,
      # if off then they are not logged
      log-received-messages = on
    }
    serializers {
      tx = "encry.modifiers.serialization.EncryTxSerializer"
      proofs = "encry.modifiers.serialization.EncryProofsSerializer"
      payload = "encry.modifiers.serialization.EncryPayloadSerializer"
      header = "encry.modifiers.serialization.EncryHeaderSerializer"
    }
    serialization-bindings {
      "encry.modifiers.mempool.Transaction" = tx
      "encry.modifiers.history.ADProofs" = proofs
      "encry.modifiers.history.Payload" = payload
      "encry.modifiers.history.Header" = header
    }
  }
}
mining-dispatcher {
  type = Dispatcher
  executor = "thread-pool-executor"
  thread-pool-executor.fixed-pool-size = 4
  throughput = 4
}
mining-mailbox {
  mailbox-type = "akka.dispatch.NonBlockingBoundedMailbox"
  mailbox-capacity = 5
}
network-dispatcher {
  type = Dispatcher
  executor = "thread-pool-executor"
  thread-pool-executor.fixed-pool-size = 1
  throughput = 1
}
nvh-dispatcher {
  type = Dispatcher
  executor = "thread-pool-executor"
  thread-pool-executor.fixed-pool-size = 1
  throughput = 1
}
nvh-mailbox {
  mailbox-type = "akka.dispatch.NonBlockingBoundedMailbox"
  mailbox-capacity = 100000
}
kafka-dispatcher {
  type = Dispatcher
  executor = "thread-pool-executor"
  thread-pool-executor.fixed-pool-size = 1
  throughput = 1
}
aux-history-dispatcher {
  type = Dispatcher
  executor = "thread-pool-executor"
  thread-pool-executor.fixed-pool-size = 2
  throughput = 1
}