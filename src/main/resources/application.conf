encry.core {
  # Directory to keep data
  directory = ${user.dir}"/encry/data"
  node {
    # Possible options are:
    # "utxo" - keep full utxo set, that allows to validate arbitrary block and generate ADProofs
    # "digest" - keep state root hash only and validate transactions via ADProofs
    stateMode = "utxo"
    # Download block transactions and verify them (requires BlocksToKeep == 0 if disabled)
    verifyTransactions = true
    # Number of last blocks to keep with transactions and ADproofs, for all other blocks only header will be stored.
    # Keep all blocks from genesis if negative
    blocksToKeep = -1
    modifiersCacheSize = 3000
    # Is the node is doing mining
    mining = true
    # Number of threads should be used for mining
    numberOfMiningWorkers = 3
    # If true, a node generates blocks being offline. The only really useful case for it probably is to start a new
    # blockchain
    offlineGeneration = false
    # Delay for miner after succesful block creation
    miningDelay = 5s
    utxMaxAge = 1000m
    mempoolCleanupInterval = 180m
    mempoolMaxCapacity = 10000
    useCli = true
    loggingMode = "file"
  }
  // Set main db to node componet. Now avaliable iodb or LevelDb
  storage {
    state = "iodb"
    auxHistory = "iodb"
    history = "iodb"
  }
  wallet {
    password = "encry"
  }
  levelDB {
    maxVersions = 100
  }
  network {
    bindAddress = "0.0.0.0:9001"
    networkChunkSize = 1000
    localOnly = false
    knownPeers = ["172.16.11.11:9001", "172.16.11.12:9001", "172.16.11.13:9001", "172.16.11.14:9001",
      "172.16.11.15:9001", "172.16.11.16:9001", "172.16.11.17:9001", "172.16.11.18:9001",
      "172.16.11.19:9001", "172.16.11.20:9001"]
    maxConnections = 20
    connectionTimeout = 1s
    handshakeTimeout = 30s
    connectOnlyWithKnownPeers = false
    syncInterval = 15s
    syncTimeout = 5s
    syncPacketLength = 1000
    deliveryTimeout = 30s
    maxDeliveryChecks = 5
    appVersion = 0.9.3
    maxInvObjects = 1000
    modifierDeliverTimeCheck = 60s
    updatePriorityTime = 10
  }
  restApi {
    enabled = true
    bindAddress = "0.0.0.0:9051"
    corsAllowed = true
    timeout = 5s
  }
  ntp {
    server = "pool.ntp.org"
    updateEvery = 30m
    timeout = 30s
  }
  testing {
    defaultRecipientAddress = "3jSD9fwHEHJwHq99ARqhnNhqGXeKnkJMyX4FZjHV6L3PjbCmjG"
    minimalFee = 100
    amount = 100
    # Maximum number of transaction generated per one epoch, set to -1 to avoid limiting
    limitPerEpoch = 100
  }
  monitoringSettings {
    kamonEnabled = false
  }
}
akka {
  log-dead-letters = 0
  log-dead-letters-during-shutdown = off
  persistence.journal.plugin = akka.persistence.journal.leveldb
  logger-startup-timeout = 60s
  loggers = ["akka.event.slf4j.Slf4jLogger"]
  actor.warn-about-java-serializer-usage = false
}
mining-dispatcher {
  type = Dispatcher
  executor = "thread-pool-executor"
  thread-pool-executor.fixed-pool-size = 4
  throughput = 4
}
mining-mailbox {
  mailbox-type = "akka.dispatch.NonBlockingBoundedMailbox"
  mailbox-capacity = 5
}
network-dispatcher {
  type = Dispatcher
  executor = "thread-pool-executor"
  thread-pool-executor.fixed-pool-size = 1
  throughput = 1
}
kafka-dispatcher {
  type = Dispatcher
  executor = "thread-pool-executor"
  thread-pool-executor.fixed-pool-size = 1
  throughput = 1
}
aux-history-dispatcher {
  type = Dispatcher
  executor = "thread-pool-executor"
  thread-pool-executor.fixed-pool-size = 2
  throughput = 1
}
block-listener-dispatcher {
  type = Dispatcher
  executor = "thread-pool-executor"
  thread-pool-executor.fixed-pool-size = 2
  throughput = 1
}